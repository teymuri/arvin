(


define f1 lambda 2022
pret call f1

define f2 lambda x: y: z: &rest: pret cith y rest
call f2 z: 0 y: 1 x: 2 &rest: 5 4 3
call f2 0 1 2 call f1
  20 30

define ith lambda i: &args: cith i args
pret call ith i: 7 1 2 3 4 5 6 7 true 9 10
)
(((())))
(
let fn: lambda i: &args: pret cith i args
    fn2: lambda fn
    let x: call fn2
      call x 0 10 20 30 40 50 60 70 80 90 100 true false


define IDX 4

define f
  lambda
    let fn: lambda i: IDX &rest:
              cith i rest
      fn

          
pret call call f
          i: 5
          &rest: 1000 2 3 4 5 6


let x: 2022
    y: x
    fn: lambda a: define F lambda pret a
    fn2: lambda define F2 lambda pret x
    let foo: y bar: foo
      call fn2 IDX
pass F2


define ith lambda i: &r: 1 2 3 4 cith i r
pret call ith i: 3 &r: 10 20 30 let x: true x 50 60
)
(hier gibts 2 punkte:
1. alles was nach &e: kommt wird in &e: gepackt
2.?)
(
call
  lambda q: w: &e:
    pret cith cith cith 0 e e e
  0 1 2 3 4 5 true 7 8 9 10
)
(
call
  lambda q: w: &e: 1 2 3 4 5 6
    pret cith cith cith q e e e
     0 1 2 3 4 5 6

call lambda q: w: &e:
        pret cith cith cith 0 e e e
     0 1 2 3 4 5 true 7 8 9 10)
(
pass
  0 1
  2 3 4 5 false 7 8 9 10
  lambda q: w: &e:
    pret
      cith
        cith
          cith
            0
            e
          e
        e


call f 1 2 3 4 5
)

(define f lambda w: 0 a: s: &rest: pret cith s rest
call f a: 4 1 w: 6 7 2 9 10 11 12)


(call
  lambda q: w: e: r: t: z: (if pret z here segfault)
    pret z
  e: 1 2 q: 3 4 5 6 7 8 9)
  
(call
  lambda &rest:
    pret tilanth 0 rest
  1 2 3 4 5 6)

(let f: lambda q: w: e: r: t: z: &rest: pret cith e rest
    call f e: 1 2 q: 3 4 0 6 &rest: false 8)

define ith
  lambda i: &items:
    tilanth i items

pret call ith i: 2 &list: 3 4 5